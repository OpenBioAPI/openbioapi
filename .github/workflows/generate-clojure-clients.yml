name: Generate Clojure Clients

on:
  workflow_dispatch:
  # push:
  #   branches:
  #     - main
  # schedule:
  #   - cron: '0 0 * * *'  # Daily at midnight UTC

env:
  TARGET_OWNER: ${{ vars.TARGET_OWNER || 'Schmoho' }}
  META_REPO: ${{ vars.META_REPO || 'openbioapi-clients-meta' }}
  PRIVATE_CLIENTS: ${{ vars.PRIVATE_CLIENTS || 'false' }}

jobs:
  generate-clients:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq

      - name: Discover OpenAPI specs
        id: discover
        run: |
          echo "Discovering OpenAPI spec files..."
          
          # Find all yaml/yml/json files that contain "openapi" or "swagger"
          SPECS=()
          for file in $(find . -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) ! -path "./.git/*"); do
            if grep -qiE '"?(openapi|swagger)"?\s*:' "$file" 2>/dev/null; then
              SPECS+=("$file")
              echo "Found spec: $file"
            fi
          done
          
          if [ ${#SPECS[@]} -eq 0 ]; then
            echo "No OpenAPI specs found"
            echo "specs_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Write specs to a JSON file for later steps
          printf '%s\n' "${SPECS[@]}" | jq -R . | jq -s '{"specs": .}' > specs.json
          cat specs.json
          echo "specs_found=true" >> $GITHUB_OUTPUT

      - name: Generate Clojure clients
        if: steps.discover.outputs.specs_found == 'true'
        run: |
          chmod +x .github/scripts/generate_single.sh
          
          mkdir -p generated_clients
          
          # Read specs from JSON and generate clients
          jq -r '.specs[]' specs.json | while read -r spec_path; do
            # Extract spec name from path
            spec_file=$(basename "$spec_path")
            spec_name="${spec_file%.*}"
            
            # Handle nested paths (e.g., uniprot/uniprot.json)
            dir_name=$(dirname "$spec_path" | sed 's|^\./||' | tr '/' '-')
            if [ "$dir_name" != "." ]; then
              # Avoid redundant names like 'uniprot-uniprot' when filename matches directory
              if [ "$spec_name" != "$dir_name" ]; then
                spec_name="${dir_name}-${spec_name}"
              else
                spec_name="$dir_name"
              fi
            fi
            
            # Sanitize spec name (lowercase, replace special chars with dash)
            spec_name=$(echo "$spec_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')
            
            client_name="clj-${spec_name}-client"
            output_dir="generated_clients/${client_name}"
            
            echo "Generating client: $client_name from $spec_path"
            
            .github/scripts/generate_single.sh "$spec_path" "$output_dir" || {
              echo "Warning: Failed to generate client for $spec_path"
              continue
            }
            
            # Record successful generation
            echo "{\"spec_path\": \"$spec_path\", \"spec_name\": \"$spec_name\", \"client_name\": \"$client_name\", \"output_dir\": \"$output_dir\"}" >> generated_list.jsonl
          done
          
          # Convert to proper JSON array
          if [ -f generated_list.jsonl ]; then
            jq -s '.' generated_list.jsonl > push_map.json
            cat push_map.json
          else
            echo "[]" > push_map.json
          fi

      - name: Create target repositories and push clients
        if: steps.discover.outputs.specs_found == 'true'
        uses: actions/github-script@v7
        env:
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            const path = require('path');
            
            const pushMap = JSON.parse(fs.readFileSync('push_map.json', 'utf8'));
            
            if (pushMap.length === 0) {
              console.log('No clients to push');
              return;
            }
            
            const targetOwner = process.env.TARGET_OWNER;
            const privateClients = process.env.PRIVATE_CLIENTS === 'true';
            const token = process.env.PERSONAL_TOKEN;
            
            if (!token) {
              core.setFailed('PERSONAL_TOKEN secret is not set');
              return;
            }
            
            const octokitClient = getOctokit(token);
            
            const results = [];
            
            // Helper function to sanitize shell arguments
            function shellEscape(str) {
              return "'" + str.replace(/'/g, "'\"'\"'") + "'";
            }
            
            // Helper function to validate path-like strings
            function isValidPath(str) {
              return /^[a-zA-Z0-9_./-]+$/.test(str);
            }
            
            for (const client of pushMap) {
              const repoName = client.client_name;
              console.log(`Processing: ${repoName}`);
              
              // Validate inputs to prevent command injection
              if (!isValidPath(client.output_dir) || !isValidPath(client.spec_path)) {
                console.error(`Invalid path detected, skipping: ${repoName}`);
                continue;
              }
              
              // Try to create repository (it may already exist)
              try {
                // First, try to create as user repo
                try {
                  await octokitClient.rest.repos.createForAuthenticatedUser({
                    name: repoName,
                    description: `Auto-generated Clojure client for ${client.spec_name} API`,
                    private: privateClients,
                    auto_init: false
                  });
                  console.log(`Created repository: ${targetOwner}/${repoName}`);
                } catch (createError) {
                  if (createError.status === 422) {
                    console.log(`Repository ${repoName} already exists`);
                  } else if (createError.status === 403 || createError.status === 401) {
                    // Try to create in org
                    try {
                      await octokitClient.rest.repos.createInOrg({
                        org: targetOwner,
                        name: repoName,
                        description: `Auto-generated Clojure client for ${client.spec_name} API`,
                        private: privateClients,
                        auto_init: false
                      });
                      console.log(`Created repository in org: ${targetOwner}/${repoName}`);
                    } catch (orgError) {
                      if (orgError.status === 422) {
                        console.log(`Repository ${targetOwner}/${repoName} already exists`);
                      } else {
                        throw orgError;
                      }
                    }
                  } else {
                    throw createError;
                  }
                }
                
                // Push to repository using git credential helper
                const outputDir = client.output_dir;
                const repoUrlNoToken = `https://github.com/${targetOwner}/${repoName}.git`;
                
                // Sanitize commit message
                const commitMessage = `Auto-generated Clojure client from ${client.spec_path}`.replace(/["`$\\]/g, '');
                
                try {
                  // Use environment variable for token instead of embedding in URL
                  execSync(`
                    cd ${shellEscape(outputDir)} && \
                    git init && \
                    git config user.email "github-actions[bot]@users.noreply.github.com" && \
                    git config user.name "github-actions[bot]" && \
                    git config credential.helper '!f() { echo "password=$GIT_TOKEN"; }; f' && \
                    git add -A && \
                    git commit -m ${shellEscape(commitMessage)} --allow-empty && \
                    git branch -M main && \
                    git remote add origin ${shellEscape(repoUrlNoToken)} && \
                    GIT_ASKPASS=echo git -c credential.username=x-access-token push -f origin main
                  `, { 
                    stdio: 'pipe',
                    env: { ...process.env, GIT_TOKEN: token }
                  });
                  console.log(`Pushed to: ${targetOwner}/${repoName}`);
                  
                  results.push({
                    source_repo: context.repo.owner + '/' + context.repo.repo,
                    spec_path: client.spec_path,
                    client_repo: `https://github.com/${targetOwner}/${repoName}`,
                    updated_at: new Date().toISOString()
                  });
                } catch (pushError) {
                  console.error(`Failed to push ${repoName}: ${pushError.message}`);
                }
              } catch (error) {
                console.error(`Error processing ${repoName}: ${error.message}`);
              }
            }
            
            // Write results for meta repo update
            fs.writeFileSync('client_results.json', JSON.stringify(results, null, 2));
            console.log('Client results:', results);

      - name: Update meta repository
        if: steps.discover.outputs.specs_found == 'true'
        uses: actions/github-script@v7
        env:
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        with:
          script: |
            const fs = require('fs');
            
            const token = process.env.PERSONAL_TOKEN;
            if (!token) {
              console.log('PERSONAL_TOKEN not set, skipping meta repo update');
              return;
            }
            
            if (!fs.existsSync('client_results.json')) {
              console.log('No client results to update');
              return;
            }
            
            const results = JSON.parse(fs.readFileSync('client_results.json', 'utf8'));
            if (results.length === 0) {
              console.log('No successful client generations to record');
              return;
            }
            
            const targetOwner = process.env.TARGET_OWNER;
            const metaRepo = process.env.META_REPO;
            
            const octokitClient = getOctokit(token);
            
            // Try to ensure meta repo exists
            try {
              try {
                await octokitClient.rest.repos.createForAuthenticatedUser({
                  name: metaRepo,
                  description: 'Meta repository tracking auto-generated Clojure API clients',
                  private: false,
                  auto_init: true
                });
                console.log(`Created meta repository: ${targetOwner}/${metaRepo}`);
              } catch (createError) {
                if (createError.status !== 422) {
                  // Try org creation
                  try {
                    await octokitClient.rest.repos.createInOrg({
                      org: targetOwner,
                      name: metaRepo,
                      description: 'Meta repository tracking auto-generated Clojure API clients',
                      private: false,
                      auto_init: true
                    });
                  } catch (orgError) {
                    if (orgError.status !== 422) {
                      console.log(`Meta repo creation skipped: ${orgError.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.log(`Meta repo already exists or creation skipped: ${error.message}`);
            }
            
            // Prepare clients.json content
            const clientsContent = {
              generated_at: new Date().toISOString(),
              source_repository: context.repo.owner + '/' + context.repo.repo,
              clients: results
            };
            
            const content = Buffer.from(JSON.stringify(clientsContent, null, 2)).toString('base64');
            
            // Try to update or create clients.json in meta repo
            try {
              // Check if file exists
              let sha = null;
              try {
                const { data: existingFile } = await octokitClient.rest.repos.getContent({
                  owner: targetOwner,
                  repo: metaRepo,
                  path: 'clients.json'
                });
                sha = existingFile.sha;
              } catch (e) {
                // File doesn't exist yet
              }
              
              await octokitClient.rest.repos.createOrUpdateFileContents({
                owner: targetOwner,
                repo: metaRepo,
                path: 'clients.json',
                message: `Update clients.json - ${new Date().toISOString()}`,
                content: content,
                sha: sha,
                committer: {
                  name: 'github-actions[bot]',
                  email: 'github-actions[bot]@users.noreply.github.com'
                }
              });
              console.log(`Updated clients.json in ${targetOwner}/${metaRepo}`);
            } catch (error) {
              console.error(`Failed to update meta repo: ${error.message}`);
            }
