name: Generate Clojure Clients

on:
  workflow_dispatch:
  # push:
  #   branches:
  #     - main
  # schedule:
  #   - cron: '0 0 * * *'  # Daily at midnight UTC

env:
  TARGET_OWNER: ${{ vars.TARGET_OWNER || 'Schmoho' }}
  META_REPO: ${{ vars.META_REPO || 'openbioapi-clients-meta' }}
  PRIVATE_CLIENTS: ${{ vars.PRIVATE_CLIENTS || 'true' }}
  GENERATOR_IMAGE: openapitools/openapi-generator-cli:latest

jobs:
  generate-clients:
    runs-on: ubuntu-latest
    permissions:
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq yq

      - name: Get generator version for caching
        id: generator-version
        run: |
          # Pull the docker image and get its digest for cache key
          docker pull ${{ env.GENERATOR_IMAGE }}
          GENERATOR_DIGEST=$(docker inspect --format='{{index .RepoDigests 0}}' ${{ env.GENERATOR_IMAGE }} | cut -d'@' -f2)
          echo "digest=${GENERATOR_DIGEST}" >> $GITHUB_OUTPUT
          echo "Generator image digest: ${GENERATOR_DIGEST}"

      - name: Discover OpenAPI specs
        id: discover
        run: |
          echo "Discovering OpenAPI spec files..."
          
          # Find all yaml/yml/json files that contain "openapi" or "swagger"
          SPECS=()
          for file in $(find . -type f \( -name "*.yaml" -o -name "*.yml" -o -name "*.json" \) ! -path "./.git/*"); do
            if grep -qiE '"?(openapi|swagger)"?\s*:' "$file" 2>/dev/null; then
              SPECS+=("$file")
              echo "Found spec: $file"
            fi
          done
          
          if [ ${#SPECS[@]} -eq 0 ]; then
            echo "No OpenAPI specs found"
            echo "specs_found=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Write specs to a JSON file with additional metadata (hash and version)
          echo '{"specs": [' > specs.json
          first=true
          for spec in "${SPECS[@]}"; do
            # Compute hash of spec file
            spec_hash=$(sha256sum "$spec" | cut -d' ' -f1)
            
            # Extract API version from spec (supports both YAML and JSON)
            if [[ "$spec" == *.json ]]; then
              api_version=$(jq -r '.info.version // empty' "$spec" 2>/dev/null || echo "")
            else
              api_version=$(yq '.info.version // ""' "$spec" 2>/dev/null || echo "")
            fi
            
            # Default to empty string if not found
            api_version=${api_version:-""}
            
            if [ "$first" = true ]; then
              first=false
            else
              echo "," >> specs.json
            fi
            
            echo "{\"path\": \"$spec\", \"hash\": \"$spec_hash\", \"api_version\": \"$api_version\"}" >> specs.json
            echo "  Spec: $spec, Hash: $spec_hash, Version: $api_version"
          done
          echo ']}'  >> specs.json
          
          cat specs.json
          echo "specs_found=true" >> $GITHUB_OUTPUT

      - name: Restore cache
        id: cache-restore
        uses: actions/cache/restore@v4
        with:
          path: .cache/generation-hashes.json
          key: clojure-clients-hashes-${{ steps.generator-version.outputs.digest }}
          restore-keys: |
            clojure-clients-hashes-

      - name: Check for changes and filter specs
        id: check-changes
        if: steps.discover.outputs.specs_found == 'true'
        run: |
          mkdir -p .cache
          
          # Load previous hashes if they exist
          if [ -f ".cache/generation-hashes.json" ]; then
            echo "Previous generation hashes found"
            cat .cache/generation-hashes.json
          else
            echo "{}" > .cache/generation-hashes.json
          fi
          
          GENERATOR_DIGEST="${{ steps.generator-version.outputs.digest }}"
          
          # Filter specs that need regeneration
          jq --arg gen_digest "$GENERATOR_DIGEST" '
            .specs as $specs |
            (input // {}) as $cache |
            {
              "specs": [
                $specs[] |
                . as $spec |
                $cache[$spec.path] as $cached |
                if ($cached != null and $cached.spec_hash == $spec.hash and $cached.generator_digest == $gen_digest) then
                  empty
                else
                  $spec
                end
              ],
              "all_specs": $specs
            }
          ' specs.json .cache/generation-hashes.json > filtered_specs.json
          
          # Check if there are any specs to process
          specs_to_process=$(jq '.specs | length' filtered_specs.json)
          total_specs=$(jq '.all_specs | length' filtered_specs.json)
          
          echo "Specs to process: $specs_to_process out of $total_specs"
          
          if [ "$specs_to_process" -eq 0 ]; then
            echo "All specs are up-to-date, skipping generation"
            echo "needs_generation=false" >> $GITHUB_OUTPUT
          else
            echo "needs_generation=true" >> $GITHUB_OUTPUT
            echo "Specs requiring generation:"
            jq -r '.specs[].path' filtered_specs.json
          fi

      - name: Generate Clojure clients
        if: steps.discover.outputs.specs_found == 'true' && steps.check-changes.outputs.needs_generation == 'true'
        run: |
          chmod +x .github/scripts/generate_single.sh
          
          mkdir -p generated_clients
          
          # Read filtered specs from JSON and generate clients
          jq -c '.specs[]' filtered_specs.json | while read -r spec_obj; do
            spec_path=$(echo "$spec_obj" | jq -r '.path')
            api_version=$(echo "$spec_obj" | jq -r '.api_version')
            spec_hash=$(echo "$spec_obj" | jq -r '.hash')
            
            # Extract spec name from path
            spec_file=$(basename "$spec_path")
            spec_name="${spec_file%.*}"
            
            # Handle nested paths (e.g., uniprot/uniprot.json)
            dir_name=$(dirname "$spec_path" | sed 's|^\./||' | tr '/' '-')
            if [ "$dir_name" != "." ]; then
              # Avoid redundant names like 'uniprot-uniprot' when filename matches directory
              if [ "$spec_name" != "$dir_name" ]; then
                spec_name="${dir_name}-${spec_name}"
              else
                spec_name="$dir_name"
              fi
            fi
            
            # Sanitize spec name (lowercase, replace special chars with dash)
            spec_name=$(echo "$spec_name" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-//;s/-$//')
            
            client_name="clj-${spec_name}-client"
            output_dir="generated_clients/${client_name}"
            
            echo "Generating client: $client_name from $spec_path (API version: $api_version)"
            
            .github/scripts/generate_single.sh "$spec_path" "$output_dir" || {
              echo "Warning: Failed to generate client for $spec_path"
              continue
            }
            
            # Record successful generation with version info
            echo "{\"spec_path\": \"$spec_path\", \"spec_name\": \"$spec_name\", \"client_name\": \"$client_name\", \"output_dir\": \"$output_dir\", \"api_version\": \"$api_version\", \"spec_hash\": \"$spec_hash\"}" >> generated_list.jsonl
          done
          
          # Convert to proper JSON array
          if [ -f generated_list.jsonl ]; then
            jq -s '.' generated_list.jsonl > push_map.json
            cat push_map.json
          else
            echo "[]" > push_map.json
          fi

      - name: Create target repositories and push clients
        if: steps.discover.outputs.specs_found == 'true' && steps.check-changes.outputs.needs_generation == 'true'
        uses: actions/github-script@v7
        env:
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        with:
          github-token: ${{ secrets.PERSONAL_TOKEN }}
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            const pushMap = JSON.parse(fs.readFileSync('push_map.json', 'utf8'));
            
            if (pushMap.length === 0) {
              console.log('No clients to push');
              return;
            }
            
            const targetOwner = process.env.TARGET_OWNER;
            const privateClients = process.env.PRIVATE_CLIENTS === 'true';
            const token = process.env.PERSONAL_TOKEN;
            
            if (!token) {
              core.setFailed('PERSONAL_TOKEN secret is not set');
              return;
            }
            
            const results = [];
            
            // Helper function to sanitize shell arguments
            function shellEscape(str) {
              return "'" + str.replace(/'/g, "'\"'\"'") + "'";
            }
            
            // Helper function to validate path-like strings
            function isValidPath(str) {
              return /^[a-zA-Z0-9_./-]+$/.test(str);
            }
            
            // Helper function to validate and sanitize git tag
            // Transforms version strings to valid git tag format:
            // - Removes invalid characters (keeps alphanumeric, dots, hyphens, underscores)
            // - Prepends 'v' if tag starts with a number (e.g., '1.0.0' -> 'v1.0.0')
            // - Returns null for empty or invalid versions
            function sanitizeTag(version) {
              if (!version || version === 'null' || version === '') return null;
              // Remove any characters that are not valid in git tags
              // Git tags can contain alphanumeric, dots, hyphens, underscores
              let tag = version.replace(/[^a-zA-Z0-9._-]/g, '-').replace(/--+/g, '-').replace(/^-|-$/g, '');
              // Prepend 'v' if the tag starts with a number
              if (tag && /^[0-9]/.test(tag)) {
                tag = 'v' + tag;
              }
              return tag || null;
            }
            
            for (const client of pushMap) {
              const repoName = client.client_name;
              console.log(`Processing: ${repoName}`);
              
              // Validate inputs to prevent command injection
              if (!isValidPath(client.output_dir) || !isValidPath(client.spec_path)) {
                console.error(`Invalid path detected, skipping: ${repoName}`);
                continue;
              }
              
              let repoExists = false;
              
              // Try to create repository (it may already exist)
              try {
                // First, try to create as user repo
                try {
                  await github.rest.repos.createForAuthenticatedUser({
                    name: repoName,
                    description: `Auto-generated Clojure client for ${client.spec_name} API`,
                    private: privateClients,
                    auto_init: false
                  });
                  console.log(`Created repository: ${targetOwner}/${repoName}`);
                } catch (createError) {
                  if (createError.status === 422) {
                    console.log(`Repository ${repoName} already exists`);
                    repoExists = true;
                  } else if (createError.status === 403 || createError.status === 401) {
                    // Try to create in org
                    try {
                      await github.rest.repos.createInOrg({
                        org: targetOwner,
                        name: repoName,
                        description: `Auto-generated Clojure client for ${client.spec_name} API`,
                        private: privateClients,
                        auto_init: false
                      });
                      console.log(`Created repository in org: ${targetOwner}/${repoName}`);
                    } catch (orgError) {
                      if (orgError.status === 422) {
                        console.log(`Repository ${targetOwner}/${repoName} already exists`);
                        repoExists = true;
                      } else {
                        throw orgError;
                      }
                    }
                  } else {
                    throw createError;
                  }
                }
                
                // Push to repository using git credential helper
                const outputDir = client.output_dir;
                const repoUrlNoToken = `https://github.com/${targetOwner}/${repoName}.git`;
                const apiVersion = client.api_version;
                const gitTag = sanitizeTag(apiVersion);
                
                // Sanitize commit message
                const commitMessage = `Auto-generated Clojure client from ${client.spec_path}`.replace(/["`$\\]/g, '');
                
                try {
                  let gitCommands;
                  
                  if (repoExists) {
                    // For existing repos: clone, copy generated files over, commit changes
                    // This preserves any manually added files (tests, workflows, etc.)
                    const cloneDir = `${outputDir}_existing`;
                    console.log(`Cloning existing repository to preserve manual additions...`);
                    
                    gitCommands = `
                      GIT_ASKPASS=echo git -c credential.username=x-access-token clone ${shellEscape(repoUrlNoToken)} ${shellEscape(cloneDir)} && \
                      cd ${shellEscape(cloneDir)} && \
                      git config user.email "github-actions[bot]@users.noreply.github.com" && \
                      git config user.name "github-actions[bot]" && \
                      rsync -av --exclude='.git' ${shellEscape(outputDir)}/ . && \
                      git add -A && \
                      git diff --cached --quiet || git commit -m ${shellEscape(commitMessage)}`;
                    
                    // Add tag creation if we have a valid version
                    // Note: Uses force flag (-f) to update tag if version hasn't changed
                    if (gitTag) {
                      console.log(`Creating tag: ${gitTag} for API version: ${apiVersion}`);
                      gitCommands += ` && \
                      git tag -f ${shellEscape(gitTag)}`;
                    }
                    
                    // Push changes (not force push, to preserve history)
                    gitCommands += ` && \
                      GIT_ASKPASS=echo git -c credential.username=x-access-token push origin main`;
                    
                    // Push tag if created
                    if (gitTag) {
                      gitCommands += ` && \
                      GIT_ASKPASS=echo git -c credential.username=x-access-token push -f origin ${shellEscape(gitTag)}`;
                    }
                  } else {
                    // For new repos: initialize and push
                    gitCommands = `
                      cd ${shellEscape(outputDir)} && \
                      git init && \
                      git config user.email "github-actions[bot]@users.noreply.github.com" && \
                      git config user.name "github-actions[bot]" && \
                      git add -A && \
                      git commit -m ${shellEscape(commitMessage)} --allow-empty && \
                      git branch -M main && \
                      git remote add origin ${shellEscape(repoUrlNoToken)} && \
                      GIT_ASKPASS=echo git -c credential.username=x-access-token push origin main`;
                    
                    // Add tag creation and push if we have a valid version
                    if (gitTag) {
                      console.log(`Creating tag: ${gitTag} for API version: ${apiVersion}`);
                      gitCommands += ` && \
                      git tag ${shellEscape(gitTag)} && \
                      GIT_ASKPASS=echo git -c credential.username=x-access-token push origin ${shellEscape(gitTag)}`;
                    }
                  }
                  
                  // Use environment variable for token instead of embedding in URL
                  execSync(gitCommands, { 
                    stdio: 'pipe',
                    env: { ...process.env, GIT_TOKEN: token }
                  });
                  console.log(`Pushed to: ${targetOwner}/${repoName}` + (gitTag ? ` with tag ${gitTag}` : ''));
                  
                  results.push({
                    source_repo: context.repo.owner + '/' + context.repo.repo,
                    spec_path: client.spec_path,
                    client_repo: `https://github.com/${targetOwner}/${repoName}`,
                    api_version: apiVersion || null,
                    git_tag: gitTag || null,
                    updated_at: new Date().toISOString()
                  });
                } catch (pushError) {
                  console.error(`Failed to push ${repoName}: ${pushError.message}`);
                }
              } catch (error) {
                console.error(`Error processing ${repoName}: ${error.message}`);
              }
            }
            
            // Write results for meta repo update
            fs.writeFileSync('client_results.json', JSON.stringify(results, null, 2));
            console.log('Client results:', results);

      - name: Update meta repository
        if: steps.discover.outputs.specs_found == 'true' && steps.check-changes.outputs.needs_generation == 'true'
        uses: actions/github-script@v7
        env:
          PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }}
        with:
          github-token: ${{ secrets.PERSONAL_TOKEN }}
          script: |
            const fs = require('fs');
            
            const token = process.env.PERSONAL_TOKEN;
            if (!token) {
              console.log('PERSONAL_TOKEN not set, skipping meta repo update');
              return;
            }
            
            if (!fs.existsSync('client_results.json')) {
              console.log('No client results to update');
              return;
            }
            
            const results = JSON.parse(fs.readFileSync('client_results.json', 'utf8'));
            if (results.length === 0) {
              console.log('No successful client generations to record');
              return;
            }
            
            const targetOwner = process.env.TARGET_OWNER;
            const metaRepo = process.env.META_REPO;
            
            // Try to ensure meta repo exists
            try {
              try {
                await github.rest.repos.createForAuthenticatedUser({
                  name: metaRepo,
                  description: 'Meta repository tracking auto-generated Clojure API clients',
                  private: false,
                  auto_init: true
                });
                console.log(`Created meta repository: ${targetOwner}/${metaRepo}`);
              } catch (createError) {
                if (createError.status !== 422) {
                  // Try org creation
                  try {
                    await github.rest.repos.createInOrg({
                      org: targetOwner,
                      name: metaRepo,
                      description: 'Meta repository tracking auto-generated Clojure API clients',
                      private: false,
                      auto_init: true
                    });
                  } catch (orgError) {
                    if (orgError.status !== 422) {
                      console.log(`Meta repo creation skipped: ${orgError.message}`);
                    }
                  }
                }
              }
            } catch (error) {
              console.log(`Meta repo already exists or creation skipped: ${error.message}`);
            }
            
            // Prepare clients.json content
            const clientsContent = {
              generated_at: new Date().toISOString(),
              source_repository: context.repo.owner + '/' + context.repo.repo,
              clients: results
            };
            
            const content = Buffer.from(JSON.stringify(clientsContent, null, 2)).toString('base64');
            
            // Try to update or create clients.json in meta repo
            try {
              // Check if file exists
              let sha = null;
              try {
                const { data: existingFile } = await github.rest.repos.getContent({
                  owner: targetOwner,
                  repo: metaRepo,
                  path: 'clients.json'
                });
                sha = existingFile.sha;
              } catch (e) {
                // File doesn't exist yet
              }
              
              await github.rest.repos.createOrUpdateFileContents({
                owner: targetOwner,
                repo: metaRepo,
                path: 'clients.json',
                message: `Update clients.json - ${new Date().toISOString()}`,
                content: content,
                sha: sha,
                committer: {
                  name: 'github-actions[bot]',
                  email: 'github-actions[bot]@users.noreply.github.com'
                }
              });
              console.log(`Updated clients.json in ${targetOwner}/${metaRepo}`);
            } catch (error) {
              console.error(`Failed to update meta repo: ${error.message}`);
            }

      - name: Update cache hashes
        if: steps.discover.outputs.specs_found == 'true' && steps.check-changes.outputs.needs_generation == 'true'
        run: |
          GENERATOR_DIGEST="${{ steps.generator-version.outputs.digest }}"
          
          # Read all specs and update the cache with successfully generated ones
          # Start with existing cache
          if [ -f ".cache/generation-hashes.json" ]; then
            cp .cache/generation-hashes.json .cache/generation-hashes-new.json
          else
            echo "{}" > .cache/generation-hashes-new.json
          fi
          
          # Read the push_map.json which contains successfully generated clients
          if [ -f "push_map.json" ]; then
            jq --arg gen_digest "$GENERATOR_DIGEST" '
              reduce .[] as $item (
                (input);
                .[$item.spec_path] = {
                  "spec_hash": $item.spec_hash,
                  "generator_digest": $gen_digest,
                  "api_version": $item.api_version,
                  "generated_at": (now | strftime("%Y-%m-%dT%H:%M:%SZ"))
                }
              )
            ' push_map.json .cache/generation-hashes-new.json > .cache/generation-hashes-updated.json
            mv .cache/generation-hashes-updated.json .cache/generation-hashes.json
          fi
          
          echo "Updated cache hashes:"
          cat .cache/generation-hashes.json

      - name: Save cache
        if: steps.discover.outputs.specs_found == 'true' && steps.check-changes.outputs.needs_generation == 'true'
        uses: actions/cache/save@v4
        with:
          path: .cache/generation-hashes.json
          key: clojure-clients-hashes-${{ steps.generator-version.outputs.digest }}
